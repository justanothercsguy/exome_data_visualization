<!DOCTYPE html>
<html lang='en-US'>
  <head>

  <title>Exome Browser</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.13.0/d3.min.js"></script>
  <script type="text/javascript" src="js/exome_processing.js"></script>
  <link rel="stylesheet" href="css/styles.css">

  </head>

  <body>
    <!-- container for horizontal bars representing exons -->
    <svg class="exon-chart"></svg>

    <!-- container for lollipop plot representing variants -->
    <svg class="variant-chart"></svg>

    <!-- container for zoomed in view of a single exon -->
    <svg class="zoom-in-single-exon-chart"></svg>

    <!-- container for zoomed-in view of lollipop plot for a single exon -->
    <svg class="zoom-in-single-exon-variant-chart"></svg>

    <!-- process data from Django server and sqlite3 database file below -->
    <script>
      /* Step 1: Get variables from the Exac dataset
       *
       * cdsStart: start of the gene's coding sequence
       * cdsEnd: end of the gene's coding sequence
       * exonStarts: array of the starting base pair index of each exon in the gene
       * exonEnds: array of the ending base pair index of each exon in the gene
       *
       * TODO: Figure out and correct bug: when cdsStart >= exonEnds[0], exon bars the
       *   and variants excluding the first coding exon partition all disappear. 
       * Check if when cdsEnd <= exonStarts[length - 1], same disappearance occurs.
       * UPDATE: Bug does not occur when drawing rectangles, so perhaps it occurs when
       * mapping variants to scale functions. Have to test to make sure.
       */

      // TEST 3 - FAILED
      // NM_005985.3, SNAI1 gene - chromosome 20
      // TODO: figure out error in the zoomed in exon view scaling
      var cdsStart = 48599596;
      var cdsEnd = 48604593;
      
      // NOTE: everything below assumes exonStarts and exonEnds are arrays of the same length
      var exonStarts = [48599512,48600360,48604408];
      var exonEnds = [48599678,48600888,48605423];	

      // create a gene object
      var gene = {
        cdsStart: cdsStart,
        cdsEnd: cdsEnd,
        numExons: 0,
        exons: setExons(exonStarts, exonEnds)
      };
      gene.numExons = gene.exons.length;

      console.log(gene);

      /* Step 2: Remove exons that end before cdsStart or start after cdsEnd
       * This way, the first exon must contain cdsStart or begin after cdsStart
       * Also, the last exon must contain cdsEnd or end before cdsEnd
       */
      var exonPositions = removeExonsBeforeStartPosition(cdsStart, exonStarts, exonEnds);
      exonStarts = exonPositions.exonStarts;
      exonEnds = exonPositions.exonEnds;

      console.log(exonStarts);
      console.log(exonEnds);

      exonPositions = removeExonsAfterEndPosition(cdsEnd, exonStarts, exonEnds);
      exonStarts = exonPositions.exonStarts;
      exonEnds = exonPositions.exonEnds;



      /* Step 3: Limit the length of the non-coding parts of an exon. 
       * The non-coding part for the exon containing cdsStart would be everything before cdsStart
       * The non-coding part for the exon containing cdsEnd would be everything after cdsEnd
       */
      const NON_CODING_LENGTH_LIMIT = 200;
      exonPositions = limitNonCodingExonLength(cdsStart, cdsEnd, exonStarts, exonEnds,
        NON_CODING_LENGTH_LIMIT);
      exonStarts = exonPositions.exonStarts;
      exonEnds = exonPositions.exonEnds;


      /* Step 4: Calculate the length of each exon. Note that an exon that has been split into
       * a coding part and a non-coding part will be counted as two separate length values.
       * Then calculate the sum of these length values, and use this sum to calculate the
       * length of each uniformly-lengthed intron for the visualization.
       */
      const EXON_COUNT = exonStarts.length;
      var exonLengths = [];
      
      exonLengths = subtractValuesOfTwoArrays(exonEnds, exonStarts);
      const SUM_EXON_LENGTHS = d3.sum(exonLengths);

      const INTRON_LENGTH = Math.ceil((SUM_EXON_LENGTHS / 2) / (EXON_COUNT - 1));
      const SUM_INTRON_LENGTHS = INTRON_LENGTH * (EXON_COUNT - 1);


      /* Step 5: Subtract each value in exonStarts and exonEnds by the offset = exonStarts[0].
       * This way, when the exons are displayed using exonStarts and exonLengths, 
       * the first exon will start at position x = 0.
       */
      OFFSET = exonStarts[0];
      exonStarts = subtractArrayByOffset(exonStarts, OFFSET);
      exonEnds = subtractArrayByOffset(exonEnds, OFFSET);
      cdsStart = cdsStart - OFFSET;
      cdsEnd = cdsEnd - OFFSET;


      /* Step 6: Calculate the domain array for d3.scaleLinear(), which consists of 
       * the starting position of each exon and intron assuming the original intron lengths. 
       * Introns with length > (3 * basePairsOutsideExonLimit) will be split into three partitions.
       * Using d3.scaleLinear, the domain array will map to variant base pair positions 
       * assuming uniformly-lengthed introns (range).
       * NOTE: Dr. Zuchner said BASE_PAIRS_OUTSIDE_EXON_LIMIT = 50 
       */
      const BASE_PAIRS_OUTSIDE_EXON_LIMIT = 50; 
      var domainAndSplitIntronIndices = getDomain(exonStarts, exonEnds, BASE_PAIRS_OUTSIDE_EXON_LIMIT);
      var domain = domainAndSplitIntronIndices.domain;
      var splitIntronIndices = domainAndSplitIntronIndices.splitIntronIndices;
      console.log(splitIntronIndices);
      console.log(domain);

      /* Step 7: Calculate exonStarts and exonEnds with uniformly-lengthed introns.
       * Note that exonEnds[i] = the starting position of intron i.
       */
      var exonStartsWithUniformIntronLengths = [];
      var exonEndsWithUniformIntronLengths = [];

      exonPositions = getExonPositionsWithUniformIntronLengths(exonStarts, exonEnds, 
        INTRON_LENGTH, exonLengths);
      exonStartsWithUniformIntronLengths = exonPositions.exonStartsWithUniformIntronLengths;
      exonEndsWithUniformIntronLengths = exonPositions.exonEndsWithUniformIntronLengths;
      console.log("exonStartsWithUniformIntronLengths"); console.log(exonStartsWithUniformIntronLengths);
      console.log("exonEndsWithUniformIntronLengths"); console.log(exonEndsWithUniformIntronLengths);

      /* Step 8: Calculate the range array for d3.scaleLinear(), which consists of 
       * the starting position of each exon and intron assuming uniformly-lengthed introns. 
       * Introns whose indices match those in the domain that were split into three partitions, 
       * will likewise be split into three partitions.
       * Using d3.scaleLinear, a domain array will map variant base pair positions 
       * assuming the original intron lengths, to the range array.
       * Then initialize the function d3.scaleLinear(), using domain and range.
       */
      var range = getRange(exonStartsWithUniformIntronLengths, exonEndsWithUniformIntronLengths,
        splitIntronIndices, INTRON_LENGTH);

      var scaleVariableIntronsToUniformIntrons = d3.scaleLinear()
        .domain(domain)
        .range(range);


      /* Step 9: Split the first and last exons into their coding and non-coding parts,
       * for exonStarts and exonEnds. Then recalculate exonLengths to include non-coding partitions.
       * 
       * For the first exon, everything before cdsStart is non-coding, while everything 
       * that is greater than or equal to cdsStart is coding.
       * For the last exon, everything after cdsEnd is non-coding, while everything 
       * that is less than or equal to cdsEnd is coding.
       */
      var exonPartitionNonCodingIndices = [];

      exonPositions = splitExonAtCodingStartPosition(cdsStart, exonStarts, exonEnds);
      exonStarts = exonPositions.exonStarts;
      exonEnds = exonPositions.exonEnds;

      if (exonPositions.nonCodingIndex != null) {
        exonPartitionNonCodingIndices.push(exonPositions.nonCodingIndex);
      }

      exonPositions = splitExonAtCodingEndPosition(cdsEnd, exonStarts, exonEnds);
      exonStarts = exonPositions.exonStarts;
      exonEnds = exonPositions.exonEnds;

      if (exonPositions.nonCodingIndex != null) {
        exonPartitionNonCodingIndices.push(exonPositions.nonCodingIndex);
      }

      exonLengths = subtractValuesOfTwoArrays(exonEnds, exonStarts);


      /* Step 10: Split the first and last exons into their coding and non-coding parts,
       * for exonStartsWithUniformIntronLengths and exonEndsWithUniformIntronLengths.
       *
       * NOTE: Calculate new position of cdsEnd with uniform intron length using d3.scaleLinear()
       * with domain = [exonStarts[0], exonEnds[0], exonStarts[1], exonEnds[1], ...] and 
       * range = [exonStartsWithUniformIntronLengths[0], exonEndsWithUniformIntronLengths[0], 
       * exonStartsWithUniformIntronLengths[1], exonEndsWithUniformIntronLengths[1], ...].
       * Then use new cdsEnd to check if last exon in exonEndsWithUniformIntronLengths needs to be split. 
       * 
       * This scaling does not need to be performed on cdsStart, because it is contained in the first exon
       * which has no adjusted intron lengths occuring before it. Hence exonStarts[0] and 
       * exonStartsWithUniformIntronLengths[0] are equal.
       */
      exonPositions = splitExonAtCodingStartPosition(cdsStart, exonStartsWithUniformIntronLengths,
        exonEndsWithUniformIntronLengths);
      exonStartsWithUniformIntronLengths = exonPositions.exonStarts;
      exonEndsWithUniformIntronLengths = exonPositions.exonEnds;

      var cdsEndWithUniformIntronLengths = scaleVariableIntronsToUniformIntrons(cdsEnd);
      
      exonPositions = splitExonAtCodingEndPosition(cdsEndWithUniformIntronLengths,
        exonStartsWithUniformIntronLengths, exonEndsWithUniformIntronLengths);
      exonStartsWithUniformIntronLengths = exonPositions.exonStarts;
      exonEndsWithUniformIntronLengths = exonPositions.exonEnds;

      /* Step 11: Render D3 chart using SVG, with taller rectangles representing coding exon partitions
       * and shorter height rectangles representing non-coding exon partitions. To represent introns,
       * render horizontal dashed lines in the white space between the rectangles.
       */ 
      const chartWidth = 800;
      const chartHeight = 20;
      const barHeightCoding = chartHeight - 2;
      const barHeightNonCoding = barHeightCoding / 2;
      const TOTAL_LENGTH = SUM_EXON_LENGTHS + SUM_INTRON_LENGTHS;
      const INTRON_LENGTH_SPLIT_INTO_THREE = roundToTwoDecimalPlaces(INTRON_LENGTH / 3);
    
      var scaleUniformIntronsToChart = d3.scaleLinear()
          .domain([0, TOTAL_LENGTH])
          .range([0, chartWidth]);

      var chart = d3.select(".exon-chart")
          .attr("width", chartWidth)
          .attr("height", chartHeight);
      
      // calculate starting positions of exon partitions
      var bar = chart.selectAll("g")
          .data(exonLengths)
        .enter().append("g")
          .attr("transform", function(d, i) { 
            if (exonPartitionNonCodingIndices.includes(i)) {
              return "translate(" + 
                scaleUniformIntronsToChart(exonStartsWithUniformIntronLengths[i]) + "," + 
                ((barHeightCoding - barHeightNonCoding) / 2) + ")";
            }
            return "translate(" + scaleUniformIntronsToChart(exonStartsWithUniformIntronLengths[i])
             + "," + 0 + ")";
          });
      
      bar.append("rect")
          .attr("fill", "#868686")
          .attr("width", scaleUniformIntronsToChart)
          .attr("height", function(d, i) {
            if (exonPartitionNonCodingIndices.includes(i)) {
              return barHeightNonCoding;
            }
            return barHeightCoding;
          });

      // Given the starting positions of uniform introns when scaled to chart, 
      // split each intron into three sections and add the starting and ending positions
      // of those sections into an array
      var intronStartsAndEndsWithUniformIntronLength = [];
      const NUM_EXONS = exonEndsWithUniformIntronLengths.length - exonPartitionNonCodingIndices.length;
      for (var i = 1; i < NUM_EXONS; i++) {
        if (!exonPartitionNonCodingIndices.includes(i)) {
          var start1 = [scaleUniformIntronsToChart(exonEndsWithUniformIntronLengths[i]), barHeightNonCoding];
          var end1 = [scaleUniformIntronsToChart(exonEndsWithUniformIntronLengths[i] + INTRON_LENGTH_SPLIT_INTO_THREE), barHeightNonCoding];
          var start2 = [scaleUniformIntronsToChart(exonEndsWithUniformIntronLengths[i] + INTRON_LENGTH_SPLIT_INTO_THREE), barHeightNonCoding];
          var end2 = [scaleUniformIntronsToChart(exonStartsWithUniformIntronLengths[i+1] - INTRON_LENGTH_SPLIT_INTO_THREE), barHeightNonCoding];
          var start3 = [scaleUniformIntronsToChart(exonStartsWithUniformIntronLengths[i+1] - INTRON_LENGTH_SPLIT_INTO_THREE), barHeightNonCoding];
          var end3 = [scaleUniformIntronsToChart(exonStartsWithUniformIntronLengths[i+1]), barHeightNonCoding];
          intronStartsAndEndsWithUniformIntronLength.push([start1, end1]);
          intronStartsAndEndsWithUniformIntronLength.push([start2, end2]);
          intronStartsAndEndsWithUniformIntronLength.push([start3, end3]);
        }
      }
      
      // Render different dashed lines for the three different sections of each intron
      // Darker and wider for the two side sections that contain variants
      // Lighter and thinner for the middle section that does not contain variants
      var lines = chart.selectAll("path")
          .data(intronStartsAndEndsWithUniformIntronLength)
          .enter().append("path")
            .style("stroke", function(d, i) {
              if (i % 3 != 1) { return "black"; }
              return "grey";
            })
            .attr("stroke-width", function(d, i) {
              if (i % 3 != 1) { return 4; }
              return 2;
            })
            .style("stroke-dasharray", function(d, i) {
              if (i % 3 != 1) { return "2,2"; }
              return "2,1";
            })
            .attr("d", d3.line());

      /* Step 13: Use unary symbol to convert strings into numbers, and implement
       * row function to tell d3.csv() how to parse each row in csv file.
       * https://bl.ocks.org/curran/d867264d468b323c2e76886d44e7e8f9
       */
      const row = function(d) {
        const chromosomeString = d['Chrom'];
        const positionString = d['Position'];
        const alleleCountString = d['Allele Count'];
        const alleleNumberString = d['Allele Number'];
        const alleleFrequencyString = d['Allele Frequency'];

        return {
          chromosome: +chromosomeString,
          reference: d['Reference'],
          alternate: d['Alternate'],
          annotation: d['Annotation'],
          position: +positionString,
          alleleCount: +alleleCountString,
          alleleNumber: +alleleNumberString,
          alleleFrequency: +alleleFrequencyString
        };
      };

      // key representing variant base pair position is mapped to an array of variant(s) in that position
      var variant_map = {};
      var variant_data = [];

      /* Step 14: Use the function d3.csv() to read through variant dataset.
       * d3.csv can request csv files from a specified url and parse them, 
       * so either we get variant data from links to csv files or from a database.
       * Dr. Zuchner would like to retrieve data from a database.
       * https://stackoverflow.com/questions/42285441/how-to-read-in-csv-with-d3-v4
       */
      
      var variant_data_file_path = 'variant_data/'
      var variant_data_file_name = 'exac_ENSG00000124216_SNAI1.csv';      

      d3.csv(variant_data_file_path + variant_data_file_name, row, function(data) {
        // Since variant positions have not been subtracted by OFFSET, add OFFSET to exonStarts and exonEnds 
        // to get threshold values for filtering out variants that are greater than NON_CODING_LENGTH_LIMIT
        // number of base pairs outside of the exon
        const LOWER_THRESHOLD = exonStarts[0] + OFFSET;
        const UPPER_THRESHOLD = exonEnds[EXON_COUNT - 1 + exonPartitionNonCodingIndices.length] + OFFSET;
        
        variant_data = data;
        data = data.filter(function(d) {
          if (d.position >= LOWER_THRESHOLD && d.position <= UPPER_THRESHOLD) {
            return true;
          }
          return false;
        });

        data.forEach(function(variant) {
          var position = variant.position;
          if (!variant_map[position]) {
            variant_map[position] = [variant];
          }
          else {
            variant_map[position].push(variant);
          }
        });

        /* Step 15: Render lollipops for variants of the exon in the general view of all exons
         */
        const mostFrequentVariantPositionCount = getMaxArrayLengthInDictionary(variant_map);
        const lollipopRectHeight = 10;
        const lollipopRectWidth = 0.2;
        const lollipopRadius = 3;
        const variantChartVerticalPadding = 20;
        const variantChartHeight = 150; // lollipopRectHeight + lollipopRadius + variantChartVerticalPadding;

        // scale lollipop rectangle height based on allele frequency
        // Dr. Zuchner said: For the scale I recommend MAF > 0.01, MAF < 0.001, MAF < 0.0001
        // Zishi: I recommend an extra MAF < 0.00001
        // Get the exponential level of the minimum value, and set yScaleMin to 1 * 10^(exponent)
        // So if min = 2.05 * 10^(-6), then yScaleMin = 1 * 10^(-6)
        var yScaleMin = d3.min(data, function(d) { return d.alleleFrequency; });
        var yScaleMinExponent = Math.floor( Math.log(yScaleMin) / Math.log(10) );
        yScaleMin = Math.pow(10, yScaleMinExponent);

        var yScaleLollipop = d3.scaleLog()
            .domain([ yScaleMin, 1 ])
            // .domain([ 0, d3.min(data, function(d) { return d.alleleFrequency; }) ])
            .range([ 0, variantChartHeight - variantChartVerticalPadding ]);

        // handle for div that will display text when hovering over over lollipop circle
        var div = d3.select("body").append("div") 
              .attr("class", "tooltip")       
              .style("opacity", 0)
              .style("font-size", 8);

        var variantChart = d3.select(".variant-chart")
            .attr("width", chartWidth)
            .attr("height", variantChartHeight);

        var lollipopRect = variantChart.selectAll("g")
            .data(data)
          .enter().append("g")
            .attr("transform", function(d) {
              return "translate(" + 
                scaleUniformIntronsToChart(scaleVariableIntronsToUniformIntrons(d.position - OFFSET)) 
                  + "," + 0 + ")";
            })
            .append("rect")
            .attr("width", lollipopRectWidth)
            .attr("height", function(d) {
              return yScaleLollipop(variant_map[d.position][0].alleleFrequency);
            })
            .attr('fill', function(d) {
              return variantAnnotationToLollipopColor(d.annotation);
            });

        var lollipopCircle = variantChart.selectAll('circle')
            .data(data)
          .enter().append('circle')
            .attr('cx', function(d) {
              return scaleUniformIntronsToChart(scaleVariableIntronsToUniformIntrons(d.position - OFFSET));
            })
            .attr('cy', function(d) {
              return yScaleLollipop(variant_map[d.position][0].alleleFrequency);
            })
            .attr('r', lollipopRadius)
            .attr('fill', function(d) {
              return variantAnnotationToLollipopColor(d.annotation);
            });

        /* Step 16: When hovering over a circle, open a tooltip displaying variant data
         * Tutorial: http://bl.ocks.org/d3noob/a22c42db65eb00d4e369
         */
        lollipopCircle.on("mouseover", function(d, i) {   
          div.transition()    
              .duration(200)    
              .style("opacity", .9); 

          // TODO: If there is more that one variant in a position, we need to show a table
          // of variants when clicking or hovering over that lollipop circle.
          // For now if a position has multiple variants, the tooltip shows the first variant
          div.html("chromosome: " + variant_map[d.position][0].chromosome + "<br/>"
            + "position: " + variant_map[d.position][0].position + "<br/>"
            + "referenceAllele: " + variant_map[d.position][0].reference + "<br/>"
            + "alternateAllele: " + variant_map[d.position][0].alternate + "<br/>"
            + "annotation: " + variant_map[d.position][0].annotation + "<br/>"
            + "alleleCount: " + variant_map[d.position][0].alleleCount + "<br/>"
            + "alleleNumber: " + variant_map[d.position][0].alleleNumber + "<br/>"
            + "alleleFrequency: " + variant_map[d.position][0].alleleFrequency + "<br/>"
            + "number of variants: " + variant_map[d.position].length)
              .style("left", (d3.event.pageX) + "px")   
              .style("top", (d3.event.pageY - 28) + "px");  
          })          
        .on("mouseout", function(d) {   
          div.transition()    
              .duration(500)    
              .style("opacity", 0);
        });

        /* Step 12: When mouse hovers over, show the hovered over exon in magnified view below.
         * Then if mouse clicks on an exon, lock that exon in a magnified view below and do not
         * change exons if a different exon is hovered over. Change the color of the clicked exon.
         * Then if mouse clicks on any exons from the top row displaying the unmagnified view, 
         * unlock the magnified exon and show an exon in magnified view when hovered over. Undo the
         * color change of the exon that is freed from the locked magnified view.
         */
        var clickToLockMagnifiedExon = false;
        var clickedExonIndex = -1;
        var hoveredExonIndex = -1;

        bar.on("mouseover", function(d, i) {
          hoveredExonIndex = i;
          
          if (!clickToLockMagnifiedExon) { 
            bar.on("click", function(d, j) {
              clickToLockMagnifiedExon = true; 
              clickedExonIndex = j;
              console.log("clicked over exon at index: " + clickedExonIndex);
              d3.select(bar._groups[0][clickedExonIndex]).select("rect").attr("fill","lightblue"); // <== D3 selector (node)
            });

            // NOTE: For now, the scale treats non-coding partition and coding partition of an exon 
            // separately when clicked. Each whole exon or exon partition will get a white area 
            // to its left and right representing introns.
            const leftMarginPadding = 30;
            var singleExonAndPaddingLength = exonLengths[hoveredExonIndex] 
              + leftMarginPadding + BASE_PAIRS_OUTSIDE_EXON_LIMIT * 2;

            var scaleSingleExonToChart = d3.scaleLinear()
                .domain([ 0, singleExonAndPaddingLength ])
                .range([ 0, chartWidth ]);
          
            var zoomInSingleExonChart = d3.select(".zoom-in-single-exon-chart")
                .attr("width", chartWidth)
                .attr("height", chartHeight);

            // Step 18: create a one-element array containing the hovered/clicked exon
            zoomInSingleExonChart.selectAll("g").remove();
            var zoomBar = zoomInSingleExonChart.selectAll("g")
                .data([ exonLengths[hoveredExonIndex] ])
              .enter().append("g")
                .attr("transform", function(d) { 
                  if (exonPartitionNonCodingIndices.includes(hoveredExonIndex)) {
                    return "translate(" + 
                      scaleSingleExonToChart(
                        BASE_PAIRS_OUTSIDE_EXON_LIMIT + leftMarginPadding
                      ) + "," + ((barHeightCoding - barHeightNonCoding) / 2) + ")";
                  }
                  return "translate(" + 
                    scaleSingleExonToChart(
                      BASE_PAIRS_OUTSIDE_EXON_LIMIT + leftMarginPadding
                    ) + "," + 0 + ")";
                });
            
            // render a single rectangle representing the hovered/clicked exon in a zoomed-in view
            zoomBar.append("rect")
                .attr("fill", "#868686")
                .attr("width", scaleSingleExonToChart)
                .attr("height", function(d) {
                  if (exonPartitionNonCodingIndices.includes(hoveredExonIndex)) {
                    return barHeightNonCoding;
                  }
                  return barHeightCoding;
                });       
            
            /* Step 19: create a horizontal line representing the extent of the limit on the number of base pairs
             * outside of the exon to be shown: https://www.dashingd3js.com/svg-paths-and-d3js
             * PROBLEM: fix the positioning of the dashed line to always end at beginning of zoomed in exon
             * SOLUTION: remove all paths and redraw a new path that will be scaled to the zoomed in exon's length
             * MAYBE A PROBLEM: The zoomed-in exon rectangle changes in length because it has to match up
             * with variants which are first scaled from variableIntronsToUniformIntrons and then from
             * singleExonToChart.
             */
            var zoomLineCoordinates = [];
            zoomLineCoordinates.push([
              [scaleSingleExonToChart( leftMarginPadding ), 0], 
              [scaleSingleExonToChart( leftMarginPadding ), barHeightNonCoding], 
              [scaleSingleExonToChart( BASE_PAIRS_OUTSIDE_EXON_LIMIT + leftMarginPadding), barHeightNonCoding]]);
            
            zoomInSingleExonChart.selectAll("path").remove();
            var zoomLine = zoomInSingleExonChart.selectAll("path")
                .data(zoomLineCoordinates)
                .enter().append("path")
                  .style("fill", "none")
                  .style("stroke", "black")
                  .attr("stroke-width", 2)
                  .style("stroke-dasharray", "2,1")
                  .attr("d", d3.line());

            // add text next to dashed line displaying the value of BASE_PAIR_OUTSIDE_EXON_LIMIT
            // Tutorial: https://www.dashingd3js.com/svg-text-element
            zoomInSingleExonChart.selectAll("text").remove();
            var text = zoomInSingleExonChart.selectAll("text")
                .data(zoomLineCoordinates)
                .enter().append("text");
            
            var textLabels = text
                .attr("x", scaleSingleExonToChart(leftMarginPadding) + 5)
                .attr("y", barHeightCoding / 3)
                .text(BASE_PAIRS_OUTSIDE_EXON_LIMIT + " bp")
                .attr("font-family", "sans-serif")
                .attr("font-size", "8px");
            
            // Step 17: Render lollipops for variants of the exon in the zoomed-in view of a single exon
            const CLICKED_EXON_OFFSET = exonStarts[hoveredExonIndex] + OFFSET;
            const CLICKED_EXON_LOWER_THRESHOLD = CLICKED_EXON_OFFSET - BASE_PAIRS_OUTSIDE_EXON_LIMIT;
            const CLICKED_EXON_UPPER_THRESHOLD = CLICKED_EXON_OFFSET 
              + exonLengths[hoveredExonIndex] + BASE_PAIRS_OUTSIDE_EXON_LIMIT;       
            
            data = variant_data.filter(function(d) {
              if (d.position >= CLICKED_EXON_LOWER_THRESHOLD 
                && d.position <= CLICKED_EXON_UPPER_THRESHOLD) {
                return true;
              }
              return false;
            });

            var variant_map_single_exon = {}
            for (let [key, value] of Object.entries(variant_map)) {
              if (key >= CLICKED_EXON_LOWER_THRESHOLD && key <= CLICKED_EXON_UPPER_THRESHOLD) {
                variant_map_single_exon[key] = value;
              }
            }
            // TODO: Figure out if there is a more efficient way than deleting the previous div 
            // and creating a new one. Current way removes tooltip when hovering over variants 
            // in the general view. This prevents user from hovering over and getting info on a 
            // few variants outside of BASE_PAIRS_OUTSIDE_EXON_LIMIT - DONT WORRY FOR NOW
            // MAYBE SOLUTION: put the tooltip in its own div so it does not get deleted - NEED TO TEST
            var body_divs = d3.select("body").select("div").remove();
            
            var div = d3.select("body").append("div") 
                  .attr("class", "tooltip")       
                  .style("opacity", 0);

            var variantChart = d3.select(".zoom-in-single-exon-variant-chart")
                .attr("width", chartWidth)
                .attr("height", variantChartHeight);

            variantChart.selectAll("g").remove();
            var lollipopRect = variantChart.selectAll("g")
                .data(data)
              .enter().append("g")
                .attr("transform", function(d) {
                  return "translate(" + 
                    scaleSingleExonToChart(
                      scaleVariableIntronsToUniformIntrons(
                        (d.position - CLICKED_EXON_OFFSET + BASE_PAIRS_OUTSIDE_EXON_LIMIT + leftMarginPadding)
                      )
                    ) + "," + (variantChartVerticalPadding / 2) + ")";
                })
                .append("rect")
                .attr("width", lollipopRectWidth)
                .attr("height", function(d) {
                  return yScaleLollipop(variant_map_single_exon[d.position][0].alleleFrequency);
                })
                .attr('fill', function(d) {
                  return variantAnnotationToLollipopColor(d.annotation);
                });

            variantChart.selectAll("circle").remove();
            var lollipopCircle = variantChart.selectAll('circle')
                .data(data)
              .enter().append('circle')
                .attr('cx', function(d) {
                  return scaleSingleExonToChart(
                    scaleVariableIntronsToUniformIntrons(
                      (d.position - CLICKED_EXON_OFFSET + BASE_PAIRS_OUTSIDE_EXON_LIMIT + leftMarginPadding)
                    )
                  );
                })
                .attr('cy', function(d) {
                  return yScaleLollipop(variant_map_single_exon[d.position][0].alleleFrequency 
                    ) + (variantChartVerticalPadding / 2);
                })
                .attr('r', lollipopRadius)
                .attr('fill', function(d) {
                  return variantAnnotationToLollipopColor(d.annotation);
                });

            /* Step 20: add vertical axis representing allele frequencies of variants in the zoomed-in view
             *
             * TODO: change length of lollipops to reflect the allele frequencies
             * Tutorial: https://bl.ocks.org/d3noob/23e42c8f67210ac6c678db2cd07a747e
             *
             * TODO: add left margin padding and y-axis padding (upper and lower bound of svg container)
             * so that the y-axis text next to tick marks will be displayed correctly
             * Tutorial: https://bl.ocks.org/mbostock/3885304
             */
            // Scale the range of the data
            var y = d3.scaleLinear()
                .domain([ 0, mostFrequentVariantPositionCount ])
                .range([ 0, variantChartHeight - variantChartVerticalPadding ]);

            // text label for the y axis
            // Note: do not remove tick mark labels before removing and re-rendering y-axis label
            // TODO: preset vertical and horizontal margins and render scale position according to margin
            variantChart.selectAll("text").remove();
            variantChart.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0)
                .attr("x", 0 - (variantChartHeight / 2))
                .attr("dy", "1em")
                .attr("text-anchor", "middle")
                .text("MAF");

            variantChart.append("g")
                .attr("class", "axis axis--y")
                .attr("transform", "translate(" + (leftMarginPadding * 2) + "," + 
                  (variantChartVerticalPadding / 2) + ")")
                .call(d3.axisLeft(yScaleLollipop));

            /* Step 16: When hovering over a circle, open a tooltip displaying variant data
              * Tutorial: http://bl.ocks.org/d3noob/a22c42db65eb00d4e369
              */
            lollipopCircle.on("mouseover", function(d, i) {   
              div.transition()    
                  .duration(200)    
                  .style("opacity", .9); 

              // TODO: If there is more that one variant in a position, we need to show a table
              // of variants when clicking or hovering over that lollipop circle.
              // For now if a position has multiple variants, the tooltip shows the first variant
              div.html("chromosome: " + variant_map_single_exon[d.position][0].chromosome + "<br/>"
                + "position: " + variant_map_single_exon[d.position][0].position + "<br/>"
                + "referenceAllele: " + variant_map_single_exon[d.position][0].reference + "<br/>"
                + "alternateAllele: " + variant_map_single_exon[d.position][0].alternate + "<br/>"
                + "annotation: " + variant_map_single_exon[d.position][0].annotation + "<br/>"
                + "alleleCount: " + variant_map_single_exon[d.position][0].alleleCount + "<br/>"
                + "alleleNumber: " + variant_map_single_exon[d.position][0].alleleNumber + "<br/>"
                + "alleleFrequency: " + variant_map_single_exon[d.position][0].alleleFrequency + "<br/>"
                + "number of variants: " + variant_map_single_exon[d.position].length)
                  .style("left", (d3.event.pageX) + "px")   
                  .style("top", (d3.event.pageY - 28) + "px");  
            })          
            .on("mouseout", function(d) {   
              div.transition()    
                  .duration(500)    
                  .style("opacity", 0);
            });
          }
          else {
            bar.on('click', function() {
              clickToLockMagnifiedExon = false;
              d3.select(bar._groups[0][clickedExonIndex]).select("rect").attr("fill","#868686");
            });
          }
          });
        });
    </script>
  </body>
</html>